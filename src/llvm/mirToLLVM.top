import "mir"
import "print"
import "types"

def next_tmp(t: &uint) string =
    s := "tmp.{t}"
    *t += 1
    s

def op(builder: &LLVMBuilderRef, stack: &[..]LLVMValueRef, tmp: &uint, func: |LLVMBuilderRef, LLVMValueRef, LLVMValueRef, string| -> LLVMValueRef) =
    a := stack.pop!
    b := stack.pop!

    stack.append func *builder, a, b, next_tmp tmp

def convert_to_LLVMModule(program: &mir.Program) =

    llvmInitializeAllTargets!
    llvmInitializeAllTargetInfos!
    llvmInitializeAllTargetMCs!
    llvmInitializeAllAsmParsers!
    llvmInitializeAllAsmPrinters!

    mod := llvmModuleCreateWithName "my_module"
    builder := llvmCreateBuilder!
    stack := [..]LLVMValueRef

    global_vars := [..]LLVMValueRef

    //0 - log_float
    log_float_type := llvmFunctionType llvmVoidType!, box [llvmFloatType!]
    log_float_func := llvmAddFunction mod, "log_float", log_float_type
    global_vars.append log_float_func

    //1 - log_int
    log_int_type := llvmFunctionType llvmVoidType!, box [llvmInt32Type!]
    log_int_func := llvmAddFunction mod, "log_int", log_int_type
    global_vars.append log_int_func


    for mir_func := program.functions do
        //param_types := []
        ret_type := llvmFunctionType llvmVoidType!, []
        llvm_func := llvmAddFunction mod, "main", ret_type
        tmp := 0

        blocks := [..]Maybe[LLVMBasicBlockRef]

        for mir_block := mir_func.all_blocks do //create indexable block list
            id := mir_block.id
            name :=
                if i == 0 then "entry"
                else id.toString!
            block := llvmAppendBasicBlock llvm_func, name

            if id >= blocks.length then
                for c := 0..(id - blocks.length + 1) do
                    blocks.append None

            blocks[id] = Some block

        for mir_block := mir_func.all_blocks do
            block := blocks[mir_block.id].unwrap!
            llvmPositionBuilderAtEnd builder, block

            for inst := *mir_block.code do
                match inst with
                    Add_i32 -> op &builder, &stack, &tmp, llvmBuildAdd
                    Add_f32 -> op &builder, &stack, &tmp, llvmBuildAdd
                    Mul_i32 -> op &builder, &stack, &tmp, llvmBuildMul
                    Mul_f32 -> op &builder, &stack, &tmp, llvmBuildMul
                    Div_i32 -> op &builder, &stack, &tmp, llvmBuildDiv
                    Div_f32 -> op &builder, &stack, &tmp, llvmBuildDiv
                    Store_bool b -> stack.append llvmConstInt llvmInt1Type!, b cast i64, false
                    Store_i32 integer -> stack.append llvmConstInt llvmInt32Type!, integer, true
                    Store_f32 f -> stack.append llvmConstReal llvmFloatType!, f
                    FuncReturn -> llvmBuildRetVoid builder
                    Read info ->
                        assert info.is_global, "Can't handle locals yet!"
                        stack.append global_vars[info.id]

                    CondJump a, b ->
                        cond := stack.pop!
                        block_then := blocks[a].unwrap!
                        block_else := blocks[b].unwrap!

                        llvmBuildCondBr builder, cond, block_then, block_else

                    Jump a ->
                        llvmBuildBr builder, blocks[a].unwrap!

                    FuncCall fptr_type ->
                        arg_count := fptr_type.args.length

                        func := stack[stack.length - arg_count - 1]
                        args := [..]LLVMValueRef

                        for c := 0..arg_count do
                            args.append stack[stack.length - arg_count + c]
                        stack.shorten 1 + arg_count

                        if types.is_kind::[types.Void] fptr_type.return_type then
                            _ := llvmBuildCall builder, func, args, ""
                        else
                            stack.append llvmBuildCall builder, func, args, next_tmp &tmp

                    _ -> panic print.obj_toString inst

    error : Maybe[&char] = None

    log "verifying module"

    if llvmVerifyModule mod, llvmAbortProcessAction, &error then
        log "llvm verification error"
        log char_buffer_toString error.unwrap!
        panic "LLVM ERROR"

    target_triple := llvmGetDefaultTargetTriple!
    target : LLVMTargetRef = _

    if llvmGetTargetFromTriple target_triple, &target, &error then
        log char_buffer_toString error.unwrap!
        log char_buffer_toString target_triple
        panic "LLVM GET TARGET FROM TRIPLE ERROR"

    cpu := "generic"
    features := ""

    target_machine := llvmCreateTargetMachine target, target_triple, cpu.to_c_string!, features.to_c_string!, llvmCodeGenLevelNone, llvmRelocStatic, llvmCodeModelDefault

    if llvmTargetMachineEmitToFile target_machine, mod, "test/main.o", llvmObjectFile, &error then
        log "error"
        log char_buffer_toString error.unwrap!
        panic "LLVM EMIT"

    log "passed"