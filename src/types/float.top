import "scope"
import "error"

//Float type
type Float =

def Float.toString(&self) string =
    "float"

def Float.to_real_type(&self, sc: &scope.Scope) Result[CompilerType, &error.CompilerError] =
    Ok self as CompilerType

def Float.duck_type(&self, other: CompilerType, sc: &scope.Scope, thrower: Thrower) Maybe[&CompilerError] =
    guard Ok real_type := other.to_real_type sc
    elif Error e then return Some e

    match real_type with
        other_type as &Float -> None
        other_type as &Int -> None
        _ -> Some make_Error thrower, "Expecting {self} not {other}"

def Float.equals(&self, other: CompilerType, sc: &scope.Scope) bool =
    is_kind::[Float] other, sc

def Float.calc_size(&self) uint = 4

float_type := Float{}

def make_Float() &Float =
    &float_type